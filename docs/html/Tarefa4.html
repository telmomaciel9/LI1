<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa4</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Telmo Maciel &lt;a96569@alunos.uminho.pt&gt;;<br />Tiago Soares &lt;a97381@alunos.uminho.pt&gt;</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Tarefa4</p></div><div id="description"><p class="caption">Description</p><div class="doc"><h1>Introdu&#231;&#227;o</h1><p>A tarefa 4 &#233; a tarefa fundamental para que o jogo ganhe &quot;vida&quot;. &#201; nesta tarefa que implementamos fun&#231;&#245;es para 
que todos os jogadores realizem um movimento, fazendo com que o jogo ganhe alguma din&#226;mica.</p><h1>Objetivos</h1><p>O objetivo desta tarefa foi calcular o efeito da passagem de um instante de tempo num estado do jogo.
Para tal, primeiro tivemos de efetuar algumas altera&#231;&#245;es na tarefa 2 de modo a que fosse poss&#237;vel efetuar 
jogadas com os fantasmas. A prioridade foi a possibilidade de movimentar os fantasmas mas tamb&#233;m foram 
implementadas, na mesma tarefa, as seguintes altera&#231;&#245;es:</p><ul><li>Fazer com que o pacman abrisse e fechasse a boca alternadamente entre cada jogada;</li><li>Fazer com que o pacman perdesse tempo em cada jogada, no caso de ele estar em modo Mega;</li><li>Fazer com que o pacman voltasse ao modo Normal caso o tempo mega dele voltasse a 0;</li><li>Fazer com que os fantasmas voltassem a modo Alive caso n&#227;o exista nenhum pacman em modo Mega.</li></ul><p>E, ap&#243;s estas altera&#231;&#245;es todas, tentamos implementar na tarefa 4 as seguintes condi&#231;&#245;es:</p><p>Os jogadores deviam progredir n jogadas em cada itera&#231;&#227;o da fun&#231;&#227;o, por exemplo:</p><ul><li>Se um jogador tivesse velocidade 0.5 este devia progredir de 2 em 2 itera&#231;&#245;es;</li><li>Se um jogador tivesse velocidade 1.5 este devia progredir de 3 a cada 2 itera&#231;&#245;es;</li><li>Se um jogador tivesse velocidade 2.0 este devia progredir de 2 em cada itera&#231;&#227;o.</li></ul><p>Por fim, tentamos criar uma fun&#231;&#227;o que realizasse todos os movimentos que os jogadores faziam em cada itera&#231;&#227;o.</p><h1>Discuss&#227;o e Conclus&#227;o</h1><p>Em conclus&#227;o, esta tarefa foi bastante r&#225;pida de realizar, exceto as altera&#231;&#245;es da tarefa 2, visto que tivemos de 
analisar o c&#243;digo todo e pensar onde poder&#237;amos implementar todas as altera&#231;&#245;es necess&#225;rias. Pensamos que esta tarefa 
ficou da melhor forma poss&#237;vel e o mais compacta poss&#237;vel e que, apesar de n&#227;o termos um local para realizar testes 
como tivemos na primeira fase, que ficou bem feita e aceita todos os casos poss&#237;veis.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:defaultDelayTime">defaultDelayTime</a> :: Integer</li><li class="src short"><a href="#v:rotatePlayer">rotatePlayer</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; Key -&gt; <a href="Types.html#t:Player" title="Types">Player</a></li><li class="src short"><a href="#v:playAll">playAll</a> :: Int -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a></li><li class="src short"><a href="#v:auxgetMoves">auxgetMoves</a> :: Int -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>] -&gt; <a href="Types.html#t:Play" title="Types">Play</a></li><li class="src short"><a href="#v:getIDPlays">getIDPlays</a> :: [<a href="Types.html#t:Play" title="Types">Play</a>] -&gt; Int -&gt; <a href="Types.html#t:Play" title="Types">Play</a></li><li class="src short"><a href="#v:reduceTimeMega">reduceTimeMega</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>]</li><li class="src short"><a href="#v:changeSpeedGhost">changeSpeedGhost</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>]</li><li class="src short"><a href="#v:passTime">passTime</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:defaultDelayTime" class="def">defaultDelayTime</a> :: Integer <a href="#v:defaultDelayTime" class="selflink">#</a></p><div class="doc"><p>Tempo predefinido de 250ms</p></div></div><div class="top"><p class="src"><a id="v:rotatePlayer" class="def">rotatePlayer</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; Key -&gt; <a href="Types.html#t:Player" title="Types">Player</a> <a href="#v:rotatePlayer" class="selflink">#</a></p><div class="doc"><p>Esta fun&#231;&#227;o tem como objetivo rotacionar o pacman conforme se prime as teclas.</p><pre>rotatePlayer (Pacman (PacState (i,(b,c), x, y,z,l) h f j)) u 
  | u==KeyUpArrow  = (Pacman (PacState (i,(b,c), x, U,z,l) h f j))
  | u==KeyDownArrow  = (Pacman (PacState (i,(b,c), x, D,z,l) h f j))
  | u==KeyLeftArrow  = (Pacman (PacState (i,(b,c), x, L,z,l) h f j))
  | u==KeyRightArrow  = (Pacman (PacState (i,(b,c), x, R,z,l) h f j))
</pre></div></div><div class="top"><p class="src"><a id="v:playAll" class="def">playAll</a> :: Int -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> <a href="#v:playAll" class="selflink">#</a></p><div class="doc"><p>Esta fun&#231;&#227;o tem como objetivo fazer com que todas as entidades (Pacman e Ghosts) joguem.</p><pre>playAll :: Int -&gt; [Player] -&gt; State -&gt; State 
playAll n [] s = s
playAll n ((Pacman (PacState (i,(b,c), x, y,z,l) h f Dying)):xs) s = s
playAll n ((Pacman (PacState (i,(b,c), x, y,z,l) h f mode)):xs) s = playAll n xs (play (Move i y) s)
playAll n  ((Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) Alive)):xs) s = playAll n xs (play (auxgetMoves i1 (ghostPlay s)) s) 
playAll n  ((Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) Dead)):xs) s 
  | mod n 2 ==0 = playAll n xs (play (scatterMode s i1) s)
  | otherwise = playAll n xs s
</pre></div></div><div class="top"><p class="src"><a id="v:auxgetMoves" class="def">auxgetMoves</a> :: Int -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>] -&gt; <a href="Types.html#t:Play" title="Types">Play</a> <a href="#v:auxgetMoves" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o auxiliar da <code><a href="Tarefa4.html#v:playAll" title="Tarefa4">playAll</a></code> (no caso dos Ghosts) para obter o movimento do respetivo fantasma.</p><pre>auxgetMoves :: Int -&gt; [Play] -&gt; Play
auxgetMoves n [] = (Move n Null)
auxgetMoves n l = (getIDPlays l n) 
</pre></div></div><div class="top"><p class="src"><a id="v:getIDPlays" class="def">getIDPlays</a> :: [<a href="Types.html#t:Play" title="Types">Play</a>] -&gt; Int -&gt; <a href="Types.html#t:Play" title="Types">Play</a> <a href="#v:getIDPlays" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o que complementa a <code><a href="Tarefa4.html#v:auxgetMoves" title="Tarefa4">auxgetMoves</a></code> para determinar a <code><a href="Types.html#t:Play" title="Types">Play</a></code> consoante o ID do fantasma desejado.</p><pre>getIDPlays :: [Play] -&gt; Int -&gt; Play
getIDPlays ((Move x ori):t) id
  | x==id = (Move x ori)
  | otherwise= getIDPlays t id
</pre></div></div><div class="top"><p class="src"><a id="v:reduceTimeMega" class="def">reduceTimeMega</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] <a href="#v:reduceTimeMega" class="selflink">#</a></p><div class="doc"><p>Esta fun&#231;&#227;o reduz o tempo do jogador do tipo Pacman caso ele esteja em modo Mega.</p><pre>reduceTimeMega :: [Player] -&gt; [Player]
reduceTimeMega [] = []
reduceTimeMega ((Pacman (PacState (i,(b,c), x, y,z,l) h f mode)):xs)
  | mode== Mega &amp;&amp; h&gt;0.25 = ((Pacman (PacState (i,(b,c), x, y,z,l) (h-0.25) f Mega)):xs)
  | mode== Mega = ((Pacman (PacState (i,(b,c), x, y,z,l) 0 f Normal)): changeSpeedGhost xs)
  | otherwise= ((Pacman (PacState (i,(b,c), x, y,z,l) 0 f mode)):xs)
</pre></div></div><div class="top"><p class="src"><a id="v:changeSpeedGhost" class="def">changeSpeedGhost</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] <a href="#v:changeSpeedGhost" class="selflink">#</a></p><div class="doc"><p>Esta fun&#231;&#227;o muda a velocidade do jogador do tipo Ghost, ficando mais lento em modo <a href="Dead.html">Dead</a>.</p><pre>changeSpeedGhost :: [Player] -&gt; [Player]
changeSpeedGhost [] = []
changeSpeedGhost ((Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) d)):xs)
  | d== Dead = (Ghost(GhoState (i1,(b1,c1), (x1*2.0), y1,z1,l1) Alive)): changeSpeedGhost xs
  | otherwise = (Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) d)): changeSpeedGhost xs
</pre></div></div><div class="top"><p class="src"><a id="v:passTime" class="def">passTime</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> <a href="#v:passTime" class="selflink">#</a></p><div class="doc"><p>Esta fun&#231;&#227;o tem como objetivo fazer com que todos os jogadores obtenham um movimento.</p><pre>passTime :: Int  -&gt; State -&gt; State
passTime x s@(State m ms l) = playAll x (reduceTimeMega (ordena ms)) s
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>