<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa2</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Telmo Maciel &lt;a96569@alunos.uminho.pt&gt;;<br />Tiago Soares &lt;a97381@alunos.uminho.pt&gt;</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Tarefa2</p></div><div id="description"><p class="caption">Description</p><div class="doc"><h1>Introdu&#231;&#227;o</h1><p>A tarefa 2 foi uma tarefa essencial visto que nos permitiu estar pela primeira vez em contacto com as
ideias fundamentais do jogo do Pacman.</p><h1>Objetivos</h1><p>Nesta tarefa o objetivo era criar as mec&#226;nicas essenciais para o funcionamento do jogo, sendo que foi
uma tarefa que serviu de alicerce para as seguintes. O nosso modo de agir centrou-se nas din&#226;micas de
a&#231;&#227;o entre as diferentes entidades. Basicamente era preciso definir as ideias do jogo, como por exemplo o
que acontece quando o pacman embate com uma parede, fantasma ou comida. Para isso, tivemos de definir
todos esses casos, assim como ideias ainda mais simples, como a movimenta&#231;&#227;o do jogador. No final, foi
uma quest&#227;o de agregar todos estes detalhes numa fun&#231;&#227;o final, sendo que foi expecialmente importante 
fazer testes, para saber como iam progredindo as jogadas implementadas.</p><h1>Discuss&#227;o e Conclus&#227;o</h1><p>Foi provavelmente a mais trabalhosa das tr&#234;s tarefas iniciais. Seguimos uma abordagem linear e focamos
na cria&#231;&#227;o de condi&#231;&#245;es para determinar o que acontecia em v&#225;rias situa&#231;&#245;es diferentes.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:movePlayer">movePlayer</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a></li><li class="src short"><a href="#v:updateWithCoords">updateWithCoords</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a></li><li class="src short"><a href="#v:updatePlayer">updatePlayer</a> :: <a href="Types.html#t:PlayAction" title="Types">PlayAction</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a></li><li class="src short"><a href="#v:changeGhostPlayer">changeGhostPlayer</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>]</li><li class="src short"><a href="#v:ghostIfPacmanIsMega">ghostIfPacmanIsMega</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>]</li><li class="src short"><a href="#v:changePacmanPlayer">changePacmanPlayer</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; <a href="Types.html#t:Player" title="Types">Player</a></li><li class="src short"><a href="#v:updateMaze">updateMaze</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a></li><li class="src short"><a href="#v:moveGhost">moveGhost</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a></li><li class="src short"><a href="#v:play">play</a> :: <a href="Types.html#t:Play" title="Types">Play</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a></li><li class="src short"><a href="#v:play2">play2</a> :: Int -&gt; [<a href="Types.html#t:Orientation" title="Types">Orientation</a>] -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:movePlayer" class="def">movePlayer</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> <a href="#v:movePlayer" class="selflink">#</a></p><div class="doc"><p>Como come&#231;o, cri&#225;mos a fun&#231;&#227;o que dado um labirinto, um jogador do tipo Pacman e a orienta&#231;&#227;o que pretendemos seguir, altera as coordenadas do jogador para que a sua movimenta&#231;&#227;o seja implementada.</p><pre>movePlayer :: Maze -&gt; Player -&gt; Orientation -&gt; Player
movePlayer (h2:t2) (Pacman (PacState (i,(b,c), x, y,z,l) h f j)) a
     | y==R &amp;&amp; a==R &amp;&amp; (b,c) == (b, ((length h2)-1)) = (Pacman (PacState(i,(b,0), x, R,z,l)h (changeMouth f) j)) --Dois casos possiveis de tuneis
     | y==L &amp;&amp; a==L &amp;&amp; (b,c) == (b,0) = (Pacman (PacState(i,(b, ((length h2)-1)), x, L,z,l)h (changeMouth f) j))
     | y== L &amp;&amp; a == L &amp;&amp; getPiece (b,c-1) (h2:t2) == Wall =(Pacman (PacState(i,(b,c), x, L,z,l)h (changeMouth f) j)) --Caso a pe&#231;a para onde transita seja parede
     | y== R &amp;&amp; a == R &amp;&amp; getPiece (b,c+1) (h2:t2) == Wall =(Pacman (PacState(i,(b,c), x, R,z,l)h (changeMouth f) j))
     | y== U &amp;&amp; a == U &amp;&amp; getPiece (b-1,c) (h2:t2) == Wall =(Pacman (PacState(i,(b,c), x, U,z,l)h (changeMouth f) j))
     | y== D &amp;&amp; a == D &amp;&amp; getPiece (b+1,c) (h2:t2) == Wall =(Pacman (PacState(i,(b,c), x, D,z,l)h (changeMouth f) j)) 
     | y== L &amp;&amp; a == L &amp;&amp; getPiece (b,c-1) (h2:t2) /= Wall =(Pacman (PacState(i,(b,c-1), x, L,z,l)h (changeMouth f) j)) --Caso a pe&#231;a para onde transita n&#227;o seja parede
     | y== R &amp;&amp; a == R &amp;&amp; getPiece (b,c+1) (h2:t2) /= Wall =(Pacman (PacState(i,(b,c+1), x, R,z,l)h (changeMouth f) j))
     | y== U &amp;&amp; a == U &amp;&amp; getPiece (b-1,c) (h2:t2) /= Wall =(Pacman (PacState(i,(b-1,c), x, U,z,l)h (changeMouth f) j))
     | y== D &amp;&amp; a == D &amp;&amp; getPiece (b+1,c) (h2:t2) /= Wall =(Pacman (PacState(i,(b+1,c), x, D,z,l)h (changeMouth f) j)) 
     | y/=a  =(Pacman (PacState(i,(b,c), x, a,z,l)h (changeMouth f) j)) 
</pre></div></div><div class="top"><p class="src"><a id="v:updateWithCoords" class="def">updateWithCoords</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> <a href="#v:updateWithCoords" class="selflink">#</a></p><div class="doc"><p>As duas pr&#243;ximas fun&#231;&#245;es recebem o jogador do tipo Pacman e o labirinto e mudam a sua pontua&#231;&#227;o consoante a pe&#231;a que se encontra na mesma posi&#231;&#227;o que o jogador.</p><pre>updateWithCoords :: Player -&gt; Maze -&gt; Player
updateWithCoords a@(Pacman (PacState (i,(b,c), x, y,z,l)h f j)) m 
    | getPiece (b,c) m == Food Little = updatePlayer EatLittle a
    | getPiece (b,c) m == Food Big = updatePlayer EatBig a
    | otherwise= if h==0 then (Pacman (PacState(i,(b,c), x, y,z,l)h f Normal)) 
                         else (Pacman (PacState(i,(b,c), x, y,z,l)h f j)) 


updatePlayer :: PlayAction -&gt; Player -&gt; Player
updatePlayer p (Pacman (PacState(i,(b,c), x, y,z,l)h f j))  = case p of EatLittle -&gt;if h==0 then (Pacman (PacState(i,(b,c), x, y,(z+1),l)h f Normal)) 
                                                                                            else (Pacman (PacState(i,(b,c), x, y,(z+1),l)h f j)) 
                                                                        EatBig -&gt; (Pacman (PacState(i,(b,c), x, y,(z+5),l)10 f Mega))
</pre></div></div><div class="top"><p class="src"><a id="v:updatePlayer" class="def">updatePlayer</a> :: <a href="Types.html#t:PlayAction" title="Types">PlayAction</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> <a href="#v:updatePlayer" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:changeGhostPlayer" class="def">changeGhostPlayer</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] <a href="#v:changeGhostPlayer" class="selflink">#</a></p><div class="doc"><p>Estas 3 fun&#231;&#245;es testam todos os casos em que o Pacman embate com um fantasma. Resultam no Pacman (no caso da fun&#231;&#227;o <code><a href="Tarefa2.html#v:changePacmanPlayer" title="Tarefa2">changePacmanPlayer</a></code>) e nos fantasmas (<code><a href="Tarefa2.html#v:changeGhostPlayer" title="Tarefa2">changeGhostPlayer</a></code>).</p><p>A fun&#231;&#227;o <code><a href="Tarefa2.html#v:ghostIfPacmanIsMega" title="Tarefa2">ghostIfPacmanIsMega</a></code> apenas transforma os fantasmas do estado Alive para Dead caso o pacman esteja em estado Mega, caso contr&#225;rio, permanece tudo igual.</p><pre>changeGhostPlayer :: Player -&gt; [Player] -&gt; Maze -&gt; [Player]
changeGhostPlayer (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) [] maze = []
changeGhostPlayer (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) ((Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) d)):hs) maze
                     | b==b1 &amp;&amp; c==c1 &amp;&amp; d==Dead = case (odd (length maze)) of True -&gt; (Ghost(GhoState (i1,(div(length (maze)) 2,(div (length (head maze)) 2)),x1,y1,z1,l1) Alive)): changeGhostPlayer (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) hs maze
                                                                               False -&gt; (Ghost(GhoState (i1,((div(length (maze)) 2)-1,(div (length (head maze)) 2)),x1,y1,z1,l1) Alive)): changeGhostPlayer (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) hs maze
                     | otherwise = (Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) d)): changeGhostPlayer (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) hs maze

ghostIfPacmanIsMega :: Player -&gt; [Player] -&gt; [Player]
ghostIfPacmanIsMega (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) [] = []
ghostIfPacmanIsMega (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) ((Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) d)):hs)
         |j==Mega &amp;&amp; h==10 =(Ghost(GhoState (i1,(b1,c1), x1/2.0, y1,z1,l1) Dead)): ghostIfPacmanIsMega (Pacman(PacState (i,(b,c), x, y,z,l) h f Mega)) hs
         |j==Mega =(Ghost(GhoState (i1,(b1,c1), x1/2.0, y1,z1,l1) d)): ghostIfPacmanIsMega (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) hs
         |j==Normal = (Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) Alive)): ghostIfPacmanIsMega (Pacman(PacState (i,(b,c), x, y,z,l) h f Normal)) hs

changePacmanPlayer :: Player -&gt; [Player] -&gt; Player
changePacmanPlayer (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) []  = (Pacman(PacState (i,(b,c), x, y,z,l) h f j))
changePacmanPlayer (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) ((Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) d)):xs)
                                          | b==b1 &amp;&amp; c==c1 = case d of Dead -&gt; (Pacman(PacState (i,(b,c), x, y,z+10,l) h f Mega))
                                                                       Alive -&gt; case l of 0 -&gt; (Pacman(PacState (i,(b,c), x, y,z,l) h f Dying))
                                                                                          _ -&gt; (Pacman(PacState (i,(b,c), x, y,z,l-1) h f j)) 
                                          | otherwise= changePacmanPlayer (Pacman(PacState (i,(b,c), x, y,z,l) h f j)) xs 
</pre></div></div><div class="top"><p class="src"><a id="v:ghostIfPacmanIsMega" class="def">ghostIfPacmanIsMega</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] <a href="#v:ghostIfPacmanIsMega" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:changePacmanPlayer" class="def">changePacmanPlayer</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; <a href="Types.html#t:Player" title="Types">Player</a> <a href="#v:changePacmanPlayer" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:updateMaze" class="def">updateMaze</a> :: <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> <a href="#v:updateMaze" class="selflink">#</a></p><div class="doc"><p>Esta fun&#231;&#227;o recebe um jogador do tipo Pacman e um labirinto, devolvendo um novo labirinto, com a pe&#231;a por onde o Pacman transitou na forma de <a href="Empty.html">Empty</a>.</p><pre>updateMaze :: Player -&gt; Maze -&gt; Maze
updateMaze (Pacman (PacState (i,(b,c), x, y,z,l) h f j)) m = replaceElemInMaze (b,c) Empty m
</pre></div></div><div class="top"><p class="src"><a id="v:moveGhost" class="def">moveGhost</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> <a href="#v:moveGhost" class="selflink">#</a></p><div class="doc"><p>Esta fun&#231;&#227;o foi criada para ser poss&#237;vel fazer a movimenta&#231;&#227;o de um fantasma.</p><pre>moveGhost :: Maze -&gt; Player -&gt; Orientation -&gt; Player
moveGhost (h2:t2) (Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) d)) Null = (Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) d))
moveGhost (h2:t2) (Ghost(GhoState (i1,(b1,c1), x1, y1,z1,l1) d)) a
     | y1== L &amp;&amp; a == L &amp;&amp; getPiece (b1,c1-1) (h2:t2) == Wall =(Ghost(GhoState (i1,(b1,c1), x1, L,z1,l1) d))--Caso a pe&#231;a para onde transita seja parede
     | y1== R &amp;&amp; a == R &amp;&amp; getPiece (b1,c1+1) (h2:t2) == Wall =(Ghost(GhoState (i1,(b1,c1), x1, R,z1,l1) d))
     | y1== U &amp;&amp; a == U &amp;&amp; getPiece (b1-1,c1) (h2:t2) == Wall =(Ghost(GhoState (i1,(b1,c1), x1, U,z1,l1) d))
     | y1== D &amp;&amp; a == D &amp;&amp; getPiece (b1+1,c1) (h2:t2) == Wall =(Ghost(GhoState (i1,(b1,c1), x1, D,z1,l1) d))
     | y1== L &amp;&amp; a == L &amp;&amp; getPiece (b1,c1-1) (h2:t2) /= Wall =(Ghost(GhoState (i1,(b1,c1-1), x1, L,z1,l1) d)) --Caso a pe&#231;a para onde transita n&#227;o seja parede
     | y1== R &amp;&amp; a == R &amp;&amp; getPiece (b1,c1+1) (h2:t2) /= Wall =(Ghost(GhoState (i1,(b1,c1+1), x1, R,z1,l1) d))
     | y1== U &amp;&amp; a == U &amp;&amp; getPiece (b1-1,c1) (h2:t2) /= Wall =(Ghost(GhoState (i1,(b1-1,c1), x1, U,z1,l1) d))
     | y1== D &amp;&amp; a == D &amp;&amp; getPiece (b1+1,c1) (h2:t2) /= Wall =(Ghost(GhoState (i1,(b1+1,c1), x1, D,z1,l1) d))
     | y1/=a  =(Ghost(GhoState (i1,(b1,c1), x1, a,z1,l1) d))
</pre></div></div><div class="top"><p class="src"><a id="v:play" class="def">play</a> :: <a href="Types.html#t:Play" title="Types">Play</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> <a href="#v:play" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa2.html#v:play" title="Tarefa2">play</a></code> &#233; a fun&#231;&#227;o final. Dada uma jogada do tipo (Move ID Orientation) e um State, devolve um novo State com as transforma&#231;&#245;es necess&#225;rias realizadas.</p><pre>play :: Play -&gt; State -&gt; State
play (Move n o) s@(State m ms l) 
  | isPacman (getPlayer n ms)== True &amp;&amp; getPacmanMode (getPlayer n ms)== Normal = (State (updateMaze (movePlayer m (whereIsPacman ms) o) m) ((changePacmanPlayer (updateWithCoords (movePlayer m (whereIsPacman ms) o)m) (whereAreGhosts ms) ):(changeGhostPlayer (updateWithCoords (movePlayer m (whereIsPacman ms) o)m) (ghostIfPacmanIsMega (updateWithCoords (movePlayer m (whereIsPacman ms) o)m)  (whereAreGhosts ms)) m))  l) 
  | isPacman (getPlayer n ms)== True &amp;&amp; getPacmanMode (getPlayer n ms)== Mega =  (State (updateMaze (movePlayer m (whereIsPacman ms') o) m) ((changePacmanPlayer (updateWithCoords (movePlayer m (whereIsPacman ms') o)m) (whereAreGhosts ms') ):(changeGhostPlayer (updateWithCoords (movePlayer m (whereIsPacman ms') o)m) (ghostIfPacmanIsMega (updateWithCoords (movePlayer m (whereIsPacman ms') o)m)  (whereAreGhosts ms')) m))  l) 
  | otherwise= replacePlayer (moveGhost m (getPlayerFromList n s) o) s 
     where reduceTimePac (Pacman (PacState (i,(b,c), x, y,z,l) h f j)) = (Pacman (PacState (i,(b,c), x, y,z,l) (h-0.25) f j))
           ms'= (replacePlayerAux (reduceTimePac (getPlayer n ms)) ms)
</pre></div></div><div class="top"><p class="src"><a id="v:play2" class="def">play2</a> :: Int -&gt; [<a href="Types.html#t:Orientation" title="Types">Orientation</a>] -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> <a href="#v:play2" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <code><a href="Tarefa2.html#v:play2" title="Tarefa2">play2</a></code> foi s&#243; criada para apoio &#224; fun&#231;ao final, esta aceita v&#225;rias jogada seguidas numa lista de orienta&#231;&#245;es e aplica-as uma a uma.</p><pre>
play2 :: Int -&gt; [Orientation] -&gt; State -&gt; State
play2 id []  s =s
play2 id (x:xs) s
   | x== R = play2 id xs (play (Move id R) s)
   | x== D = play2 id xs (play (Move id D) s)
   | x== L = play2 id xs (play (Move id L) s)
   | x== U = play2 id xs (play (Move id U) s)</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>